#!/usr/bin/env perl
########################################################################
# mrb gitCheckout - Check out repositories and suites from git into an
#                   mrb source area.
########################################################################

use 5.016;

use strict;

########################################################################
# Modules.
use Cwd qw(chdir :DEFAULT);
use Data::Dumper;
use File::Basename;
use File::Spec;
use Getopt::Long;
use Pod::Usage;
use warnings;

########################################################################
# Preamble: configuration, globals and prototypes.
Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

my $prog = basename($0);
my $libexec = dirname($0);
my $options = {};
my $default_repo_type = "fnal";
my $known_suites =
  { larsoft => [qw(larcore lardata larevt larsim larsimrad larsimdnn larg4 larreco larrecodnn
                   larana larexamples lareventdisplay larpandora larfinder
                   larwirecell larsoft)],
    art => [qw(cetlib_except cetlib fhiclcpp messagefacility hep_concurrency
               canvas canvas_root_io art art_root_io gallery critic)],
    critic => [qw(cetlib_except cetlib hep_concurrency fhiclcpp messagefacility
                  canvas canvas_root_io art art_root_io gallery critic)],
    dune => [qw(dunecore duneopdet dunesim dunecalib duneprototypes dunedataprep
                dunereco duneana duneexamples dunesw duneutil protoduneana)],
    gallery => [qw(cetlib_except cetlib hep_concurrency fhiclcpp messagefacility
                   canvas canvas_root_io fhiclpy gallery)],
    larsoftobj => [qw(larcoreobj lardataobj larcorealg lardataalg larvecutils larsoftobj)],
    nu => [qw(nusimdata nuevdb nug4 nugen nurandom nutools)],
    uboone=> [qw(uboonecode ubutil uboonedata ublite ubana ubreco ubsim
                 ubevt ubraw ubcrt ubcore ubcv ubobj)],
    sbn => [qw(icaruscode icarusutil icarusalg sbndcode sbndutil icarus_signal_processing
               sbnana sbnanaobj sbncode sbnobj sbndqm)],
    sbndaq => [qw(sbndaq sbndaq_artdaq sbndaq_artdaq_core sbndaq_xporter
                  sbndaq_minargon sbndaq_online sbndaq_decode)],
    artdaq => [qw(artdaq_core artdaq_core_demo artdaq_utilities
                  artdaq_ganglia_plugin artdaq_epics_plugin
                  artdaq_database artdaq_daqinterface
                  artdaq_mpich_plugin artdaq_mfextensions)]
  };

my $global_tree_ish;

my $version = "3.0.1";

# Declare prototypes for repository handlers here, implement wherever
# you like. Specify the appropriate handler in $repo_handlers, below.
sub fnal_repo;
sub github_repo;
sub prod_info;

# Declare known repo handlers.
my $repo_handlers =
  { fnal => \&fnal_repo,
    github => \&github_repo,
    bitbucket => undef, # Known but unimplemented currently.
    gitlab => undef, # Known but unimplemented currently.
    local => undef, # Known but unimplemented currently.
    user => sub { return { user => { repo => @_ } }; } # Basic from cmd args.
  };

# Declare prototypes for repository post-processors here.
sub github_fork;
sub git_flow_init;

# Declare URL verifiers here.
sub verified_fnal_url;
sub verified_github_url;

########################################################################
# Known specs.
#
# Repo type is chosen for a known spec in the following order:
#
# 1. As specified in the spec on the command line.
# 2. --repo-type.
# 3. First listed type from the corresponding entry in @known_specs.
# 4. $default_repo_type.
#
########################################################################
my $art_github = "art-framework-suite";
my @known_specs_art =
  (
   ["cetmodules", { github => ["FNALssi/cetmodules", user => "FNALssi"] }],
   ["cetlib_except", { github => ["$art_github/cetlib-except"] }],
   ["hep_concurrency", { github =>  ["$art_github/hep-concurrency"] }],
   ["fhiclcpp", { github => ["$art_github/fhicl-cpp"] }],
   ["art", { github => ["$art_github/art", git_args => [ qw(--recurse-submodules) ]] }],
   ["canvas_root_io", { github => ["$art_github/canvas-root-io" ] }],
   ["art_root_io", { github => ["$art_github/art-root-io" ] }],
   ["fhiclpy", { github => ["$art_github/fhicl-py" ] }],
   ["ifdh_art", { github => ["$art_github/ifdh-art" ] }]
  );

# Fill in art suite members whose product names match their repository
# names and aren't already in @known_specs_art.
my $art_special = { map { $_->[0] => 1; } @known_specs_art };
push @known_specs_art,
  map { ($art_special->{$_}) ? () : [$_, { github => ["$art_github/$_"] }]; }
  @{$known_suites->{art}};

my @known_specs_artdaq =
  (
   ["artdaq_core", { fnal => ["artdaq-core", user => "artdaq"] }],
   ["artdaq_core_demo", { fnal => ["artdaq-core-demo"] }],
   ["artdaq_demo", { fnal => ["artdaq-demo"] }],
   ["artdaq_utilities", { fnal => ["artdaq-utilities"] }],
   ["artdaq_ganglia_plugin", { fnal => ["artdaq-utilities-ganglia-plugin", user => "artdaq-utilities"] }],
   ["artdaq_epics_plugin", { fnal => ["artdaq-utilities-epics-plugin", user => "artdaq-utilities"] }],
   ["artdaq_database", { fnal => ["artdaq-utilities-database", user => "artdaq-utilities"] }],
   ["artdaq_daqinterface", { fnal => ["artdaq-utilities-daqinterface", user => "artdaq-utilities"] }],
   ["artdaq_mpich_plugin", { fnal => ["artdaq-utilities-mpich-plugin", user => "artdaq-utilities"] }],
   ["artdaq_mfextensions", { fnal => ["mf-extensions-git"] }]
  );

my @known_specs_dune =
  (
   ["garsoft", { github => ["DUNE/garsoft"] }],
   ["garana", { github => ["DUNE/garana"] }],
   ["duneanaobj", { github => ["DUNE/duneanaobj"] }],
   ["dunecore", { github => ["DUNE/dunecore"] }],
   ["duneopdet", { github => ["DUNE/duneopdet"] }],
   ["dunesim", { github => ["DUNE/dunesim"] }],
   ["dunecalib", { github => ["DUNE/dunecalib"] }],
   ["duneprototypes", { github => ["DUNE/duneprototypes"] }],
   ["dunedataprep", { github => ["DUNE/dunedataprep"] }],
   ["dunereco", { github => ["DUNE/dunereco"] }],
   ["duneana", { github => ["DUNE/duneana"] }],
   ["duneexamples", { github => ["DUNE/duneexamples"] }],
   ["dunesw", { github => ["DUNE/dunesw"] }],
   ["duneutil", { github => ["DUNE/duneutil"] }],
   ["dunepdlegacy", { github => ["DUNE/dunepdlegacy"] }],
   ["protoduneana", { github => ["DUNE/protoduneana"] }]
  );

my @known_specs_expt =
  (
   ["lariatfragments", { fnal => ["lariat-online-lariatfragments", user => "lariat-online"] }],
   ["lariatutil", { fnal => ["lardbt-lariatutil", user => "lardbt"] }],
   ["lbne_raw_data", { fnal => ["lbne-raw-data"] }]
  );

# NuSoftHEP
my $nu_github = "NuSoftHEP";
my @known_specs_nu =
  (
   ["nutools", { github => ["$nu_github/nutools"] }],
   ["nuevdb", { github => ["$nu_github/nuevdb"] }],
   ["nug4", { github => ["$nu_github/nug4"] }],
   ["nugen", { github => ["$nu_github/nugen"] }],
   ["nurandom", { github => ["$nu_github/nurandom"] }],
   ["nusimdata", { github => ["$nu_github/nusimdata"] }],
   ["geant4reweight", { github => ["$nu_github/geant4reweight"] }]
  );

my $sbn_github = "SBNSoftware";
my @known_specs_sbn =
  (
   ["sbncode", { github => ["$sbn_github/sbncode", git_args => [ qw(--recurse-submodules) ]] }]
  );
# Fill in SBN suite members whose product names match their repository
# names and aren't already in @known_specs_sbn.
my $sbn_special = { map { $_->[0] => 1; } @known_specs_sbn };
push @known_specs_art,
  map { ($sbn_special->{$_}) ? () : [$_, { github => ["$sbn_github/$_"], fnal => [$_] }]; }
  @{$known_suites->{sbn}}, qw(sbnci sbnutil);

my @known_specs_sbndaq =
  (
   ["sbndaq", { github => ["$sbn_github/sbndaq"] }],
   ["sbndaq_artdaq", { github => ["$sbn_github/sbndaq-artdaq"] }],
   ["sbndaq_artdaq_core", { github => ["$sbn_github/sbndaq-artdaq-core"] }],
   ["sbndaq_xporter", { github => ["$sbn_github/sbndaq-xporter"] }],
   ["sbndaq_minargon", { github => ["$sbn_github/sbndaq-minargon"] }],
   ["sbndaq_online", { github => ["$sbn_github/sbndaq-online"] }],
   ["sbndaq_decode", { github => ["$sbn_github/sbndaq-decode"] }]
  );

my @known_specs_larsoft =
  map { [$_, { github => ["LArSoft/$_"] }]; }
  @{$known_suites->{larsoftobj}},
  @{$known_suites->{larsoft}},
  qw(
      larpandoracontent
      larbatch
      larutils
      larsimdnn
      webevd
      nusystematics
      systematicstools
   );

my $known_specs =
  [
    @known_specs_art,
    @known_specs_artdaq,
    @known_specs_dune,
    @known_specs_expt,
    @known_specs_nu,
    @known_specs_sbn,
    @known_specs_sbndaq,
    @known_specs_larsoft
  ];

my $known_products =  { map { @{$_}; } @{$known_specs} };

########################################################################
# Subroutines.

####################################
# process_args - process incoming arguments to a subroutine into a
#                hashref.
#
# Usage: process_args(@args)
#
# Positional arguments are saved (in order) as an array in
# $hash->{positional}.
sub process_args {
  my $args = { positional => [] };
  while (scalar @_ > 0) {
    next unless defined (my $arg = shift); # Not an argument.
    if ($arg =~ m&^-(\w+)$&o) {
      $args->{${1}} = shift;
    } else {
      push @{$args->{positional}}, $arg;
    }
  }
  return $args;
}

####################################
# report - Print messages at the specified level.
#
# Usage: report(@msgs, kwargs)
#
# Keyword arguments: -level => "INFO"|"WARNING"|"ERROR"|"VERBOSE"|"DEBUG"
#                      Level of the provided message.
#
# WARNING and ERROR messages are sent to STDERR, all others to
# STDOUT.
sub report {
  my $args = process_args(@_);
  my $level = $args->{level} || "INFO";
  my $out = \*STDOUT;
  if ($level eq "WARNING" or $level eq "ERROR") {
    $out = \*STDERR;
  } elsif ($options->{quiet} or
           ($level eq "VERBOSE" and not $options->{verbose}) or
           ($level eq "DEBUG" and not $options->{debug})) {
    return;
  }
  print $out "$level: ", join("", @{$args->{positional}}), "\n";
}


####################################
# error - Report an error and exit.
#
# Usage: error(@msgs)
#
# Keyword arguments: -exitval => #
#                      Exit code.
#                    -usage => 1|0
#                      Print short usage if true.
sub error {
  my $args = process_args(@_);
  my $exitval = $args->{exitval} || 1;
  report(@{$args->{positional}}, -level => "ERROR");
  if ($args->{usage} || 0) {
    pod2usage(-exitval => $exitval, -width => 132);
  } else {
    exit($exitval);
  }
}

####################################
# fnal_repo - Handle a FNAL Redmine repository specification.
#
# Usage: fnal_repo($product, $repo, [$user], [%extras])
#
# Returns a repo type info hashref.
sub fnal_repo {
  my ($repo, %extras) = @_;
  my $user = (delete $extras{user}) || repo_name($repo);
  return
    { fnal =>
      {
       repo => $repo,
       user => $user,
       ssh_access => "p-$user\@cdcvs.fnal.gov",
       rw_url => "ssh://p-$user\@cdcvs.fnal.gov/cvs/projects/$repo",
       ro_url => "http://cdcvs.fnal.gov/projects/$repo",
       post => \&git_flow_init,
       url_picker => \&verified_fnal_url,
       %extras
      }
    };
};

####################################
# github_repo - Handle a GitHub repository specification.
#
# Usage: github_repo($repo, %extra)
#
# Returns a repo type info hashref.
sub github_repo {
  my ($repo, %extras) = @_;
  return
    { github =>
      {
       repo => $repo,
       ssh_access => "git\@github.com",
       rw_url => "git\@github.com:$repo.git",
       ro_url => "https://github.com/$repo.git",
       fork => \&github_fork,
       url_picker => \&verified_github_url,
       %extras
      }
    };
}

sub merged_product {
  my ($product, $selected_type, %prod_args) = @_;
  my $final_type = $selected_type;
  my $known_prod_args = $known_products->{$product};
  if ($selected_type eq 'user') {
    $final_type = $options->{"repo-type"} || $default_repo_type;
    if (not $known_prod_args->{$final_type}) {
      if (scalar keys %{$known_prod_args} > 1) {
        error("unable to ascertain unambiguous repository type for known product $product: please specify");
      } elsif (scalar keys %{$known_prod_args} == 1) {
        $final_type = (keys %{$known_prod_args})[0];
      }
    }
  }
  my $known_repo = shift @{$known_prod_args->{$final_type}};
  my $selected_repo = shift @{$prod_args{repo_args}};
  my @repo_bits = (repo_org($selected_repo) // repo_org($known_repo) // (),
                   repo_name($selected_repo) || repo_name($known_repo));
  $selected_repo = join("/", @repo_bits);
  my $repo_info =
    {
     @{$known_prod_args->{$final_type}},
     @{delete $prod_args{repo_args} or []}
    };
  if ($prod_args{$selected_type}->{git_args} and $prod_args{append_git_args}) {
    unshift @{$repo_info->{git_args}}, @{$known_prod_args->{$final_type}->{git_args}};
  }
  return
    {
     product => $product,
     %prod_args,
     selected_type => $final_type,
     %{handle_repo($final_type, $selected_repo, %{$repo_info})}
     };
}

####################################
# prod_info - Return a composite repository info specification.
#
# Returns a composite prod_info hashref
sub prod_info {
  my ($product, $repo_type, %prod_args) = @_;
  my $result;
  if ($options->{"no-expand"} or not $known_products->{$product}) {
    my $repo_args = delete $prod_args{repo_args};
    delete $prod_args{append_git_args};
    $result =
      {
       product => $product,
       %prod_args,
       selected_type => $repo_type,
       %{handle_repo($repo_type, @{$repo_args})}
      };
  } else {
    $result = merged_product($product, $repo_type, %prod_args);
  }
  return $result;
}

####################################
# repo_type_request - message text to file a feauture request to
#                     implement a repository handler.
#
# Usage: repo_type_request($type)
#
# Returns: message text.
sub repo_type_request {
  my $type = shift;
  return "file a feature request at https://github.com/art-framework-suite/mrb/issues/new?assignees=&labels=feature&template=feature_request.md&title=Need\%20git\%20checkout\%20support\%20for\%20$type\%20repositories";
}

####################################
# unimplemented_repo_type - report an error for an unimplemented
#                           repository type.
#
# Usage: unimplemented_repo_type($product, $repo, $user)
#
# Informs the user on the procedure for requesting support for the
# unimplemented type.
sub unimplemented_repo_type {
  my ($type, $repo, @args) = @_;
  error("unimplemented handler \"$type\" for repository \"$repo\": ", repo_type_request($type));
}

####################################
# handle_repo - Invoke the correct repo handler.
#
# Usage: handle_repo($type, @handler_args)
#
# @handler_args are passed through to the invoked handler.
#
# Returns the return value of the invoked handler.
sub handle_repo {
  my ($type, @args) = @_;
  unless ($type and exists $repo_handlers->{$type}) {
    error("unrecognized repo type $type or other repo handling error");
  }
  my $handler = $repo_handlers->{$type} // sub { unimplemented_repo_type($type, @_); };
  return &{$handler}(@args);
}


####################################
# split_type_repo - Split the repo into type:repo
#
# Usage: split_type_repo($repo_clause)
#
# Returns a tuple of ($type, $value) from an input string of
# [<type>:]<value>.
sub split_type_repo {
  my $repo = shift;
  return ($repo =~ m&^(?:(.*?):)?(.*)$&);
}



####################################
# process_repo_spec - Process a repo spec into a prod_info hash
#
# Usage: process_repo_spec($repo_spec)
#
# Returns the prod_info hash.
my $_product_re = qr&(?<product>.*?)%&msx;
my $_user_url_re = qr&(?<user_url>.*?://.*?)&msx;
my $_tree_ish_re = qr&@(?<tree_ish>[^/]+)&msx;
my $_git_args_re = qr&(?<ga_append>\+?)\^(?<git_args>.*?)&msx;
my $_repo_user_re = qr&(?<repo>.*?)(?:%(?<user>.*))?&msx;

sub process_repo_spec {
  my ($repo_spec) = @_;
  my ($product, $repo_type, $repo);
  my @repo_args = ();
  if ($repo_spec =~ m&\A$_product_re?$_user_url_re?$_tree_ish_re?$_git_args_re?\Z&msx) {
    # [<product>%]<user-url>[@<tree-ish>][^<git-arg>[^<git-arg>]...]
    $repo = $+{product} || repo_name($+{user_url});
    $product = $repo;
    push @repo_args, user_url => $+{user_url};
  } elsif ($repo_spec =~ m&\A$_product_re?$_repo_user_re?$_tree_ish_re?$_git_args_re?\Z&msx) {
    # [<product>%][<type>:]<repo>[%<user>][@<tree-ish>][[+]^<git-arg>[^<git-arg>]...] OR
    # [<type>:]<product>[@<tree-ish>][[+]^<git-arg>[^<git-arg>]...]
    ($repo_type, $repo) = split_type_repo($+{repo} || $+{product});
    my $repo_name = repo_name($repo);
    $product = $repo_name || $+{product};
    $+{user} and push @repo_args, user => $+{user};
  } else {
    error("unrecognized repo spec ${repo_spec}.\n");
  }
  $product =~ s&\.git\Z&&msx;
  $repo_type or $repo_type = $options->{"repo-type"} || "user";
  defined $+{git_args} and push @repo_args, git_args => [split(m&\^&, $+{git_args})];
  my $prod_info =
    prod_info($product,
              $repo_type,
              $+{ga_append} ? (append_git_args => 1) : (),
              $+{tree_ish} ? (tree_ish => $+{tree_ish}) : (),
              repo_args => [ $repo, @repo_args ]
             );
  report("repository info:\n",
         Dumper $prod_info,
         -level => "VERBOSE");
  return $prod_info;
}

sub repo_name {
  my ($repo) = @_;
  my ($repo_name) = ($repo =~ m&/([^/]*)\Z&msx);
  return $repo_name // $repo;
}

sub repo_org {
  my ($repo) = @_;
  my ($repo_org) = ($repo =~ m&\A([^/]*)/&msx);
  return $repo_org;
}

####################################
# expand_suite - Expand recognized suites into their constituent
#                repositories.
#
# Usage: expand_suite($repo_spec)
#
# Returns: expanded list of repositories for the given suite or ().
#
# If the given suite also specifies a tree-ish, it is appended to each
# repository spec. version tags are translated to full suite version
# tags when appropriate.
sub expand_suite {
  my $repo_spec = shift;
  my ($suite, $treeish);
  my $known_suites_expr = join("|", sort keys %{$known_suites});
  report("checking $repo_spec against $known_suites_expr", -level => "DEBUG");
  if (($suite, $treeish) =
      ($repo_spec =~ m&^($known_suites_expr)_suite(?:@(.*))?$&o)) {
    report("expanding $repo_spec");
  } else {
    return ();
  }
  if ($treeish and $treeish =~ m&^v\d+.*$&o) {
    $treeish = sprintf("%s_SUITE_${treeish}", uc ${suite});
    report("using tag $treeish for suite $suite");
  }
  return map { sprintf("${_}%s", $treeish ? "\@${treeish}" : ""); }
    @{$known_suites->{$suite}};
}

####################################
# have_read_access - verify we have at least read access to the
#                    specified repository.
#
# Usage: have_read_acces($url)
#
# Returns true on success.
sub have_read_access {
  my $url = shift;
  return system(sprintf("git ls-remote -q '%s' >%s 2>&1",
                        $url,
                        File::Spec->devnull())) == 0;
}

####################################
# verified_url - Return a verified repository URL.
#
# Usage: verified_url($typed_repo_info)
#
# Interrogates the provided typed_repo_info hashref to ascertain the best URL
# to use to clone the repository.
#
# Returns a verified URL.
sub verified_url {
  my $repo_type = shift;
  my $typed_repo_info = shift;
  my $read_only = shift || $options->{"read-only"};
  return ($typed_repo_info->{user_url}
          or ($typed_repo_info->{url_picker})
          ? &{$typed_repo_info->{url_picker}}($repo_type, $typed_repo_info, $read_only)
          : ($typed_repo_info->{rw_url} || $typed_repo_info->{ro_url}));
}

sub verified_fnal_url {
  my ($repo_type, $typed_repo_info, $read_only)  = @_;
  if ($read_only and exists $typed_repo_info->{ro_url}) {
    if (have_read_access($typed_repo_info->{ro_url})) {
      return $typed_repo_info->{ro_url};
    } else {
      error("unable to verify read access to remote $typed_repo_info->{ro_url}");
    }
  } elsif ($typed_repo_info->{rw_url}) {
    if ($repo_type eq "fnal" and
        exists $typed_repo_info->{ssh_access}) {
      # We can verify write access to this one.
      report("checking write access to $typed_repo_info->{ssh_access}", -level => "VERBOSE");
      my $bad = `ssh $typed_repo_info->{ssh_access} echo hi 2>&1 | grep -E 'Permission|authentication' | grep -v 'fake authentication' | wc -l`;
      if ($bad == 1) {
        report("unable to verify write access for $typed_repo_info->{repo}, falling back to read-only");
        return verified_fnal_url($repo_type, $typed_repo_info, 1);
      } else {
        return $typed_repo_info->{rw_url};
      }
    } elsif (have_read_access($typed_repo_info->{rw_url})) {
      return $typed_repo_info->{rw_url};
    } else {
      error("unable to verify at least read access to remote $typed_repo_info->{rw_url}");
    }
  } else {
    error("unable to ascertain URL for $typed_repo_info->{repo}");
  }
}

sub verified_github_url {
  my ($repo_type, $typed_repo_info, $read_only)  = @_;
  if ($read_only and exists $typed_repo_info->{ro_url}) {
    if (have_read_access($typed_repo_info->{ro_url})) {
      return $typed_repo_info->{ro_url};
    } else {
      error("unable to verify read access to remote $typed_repo_info->{ro_url}");
    }
  } elsif ($typed_repo_info->{rw_url} and have_read_access($typed_repo_info->{rw_url})) {
    # Write access can only be verified once repo is cloned.
    return $typed_repo_info->{rw_url};
  } elsif ($typed_repo_info->{ro_url}) {
    return $typed_repo_info->{ro_url};
  } else {
    error("unable to verify at least read access to remote $typed_repo_info->{rw_url} and no fallback R/O URL");
  }
}

####################################
# clone_repo - Execute git clone for the specified URL.
#
# Usage: clone_repo($url, $destination)
sub clone_repo {
  my ($url, $destination, @git_args) = @_;
  my @clone_cmd = (qw(git clone), @git_args, $url, $destination);
  if ($options->{"dry-run"}) {
    report(sprintf("would execute command %s", join(" ", @clone_cmd)),
           -level => "INFO");
  } else {
    report(sprintf("executing clone command: %s", join(" ", @clone_cmd)),
           -level => "VERBOSE");
    system(@clone_cmd) == 0 or
      error("unable to execute clone command: ", join(" ", @clone_cmd));
  }
}

####################################
# checkout_tree_ish - Execute git checkout with the specified tree-ish.
#
# Usage: checkout_tree_ish($destination, $tree_ish)
# 
sub checkout_tree_ish {
  my ($destination, $tree_ish) = @_;
  my $checkout_cmd =
    sprintf("(cd \"%s\" && git checkout \"%s\")",
            File::Spec->catdir($ENV{MRB_SOURCE}, $destination),
            $tree_ish);
  system($checkout_cmd) == 0 or
    error("unable to check out ${tree_ish} in ${destination}");
}

####################################
# git_flow_init - Initialize git flow for the specified repository.
#
# Usage: git_flow_init($destination, $options)
#
sub git_flow_init {
  my ($destination, $options) = @_;
  report("initializing git flow for $destination", -level => 'VERBOSE');
  my $path = File::Spec->catdir($ENV{MRB_SOURCE}, $destination);
  # This elaborate procedure is necessary for those packages where the
  # default branch is not master and master does not exist.
  my $output = `(cd \"${path}\" && { git checkout develop || git checkout -b develop; } && { git checkout master || git checkout -b master; } && git flow init -fd && git checkout develop) 2>&1`;
  if ($? == 0) {
    # If we had to create any branches, inform the user how they should
    # be pushed.
    my @branch_check = `( cd \"${path}\" && git branch -a ) 2>&1`;
    $? == 0 or error("unable to execute git branch -a to examine branches");
    foreach my $branch (qw(develop master)) {
      grep m&\borigin/$branch\b&, @branch_check or
        report("branch $branch has been created: when pushing upstream, use `git push -u' to configure future pull operations");
    }
  } else {
    error("unable to initialize git flow in $path: exit, code ",
          $? >> 8, ", output:\n", $output);
  }
}

####################################
# github_fork - Run hub fork for the specified repository.
#
# Usage: github_fork($destination, $options)
#
sub github_fork {
  my ($destination, $options) = @_;
  my $path = File::Spec->catdir($ENV{MRB_SOURCE}, $destination);
  report("forking Github repo for $destination", -level => 'VERBOSE');
  my ($fork_cmd, $fork_output) = (system("gh auth status >/dev/null 2>&1") == 0)
    ? gh_fork($path, $options)
    : hub_fork($path, $options);
  my $status = $?;
  if ($status == 0) {
    # Handle created branches.
    my $remote = `(cd \"${path}\" && git remote | grep -v upstream | head -1) 2>&1`;
    $? == 0 or error("forked repo $remote is not defined");
    # If we had to create any branches, inform the user how they should
    # be pushed.
    my @remotebranches= `( cd \"${path}\" && git branch -a | grep remotes ) 2>&1`;
    $? == 0 or error("unable to execute git branch -a to examine all branches");
    report("remote branches:\n @remotebranches\n",-level => 'VERBOSE');
    my @localbranches=`( cd \"${path}\" && git branch -a | grep -v remotes | tr '*' ' ') 2>&1`;
    $? == 0 or error("unable to execute git branch -a to examine all branches");
    report("local  branches:\n @localbranches\n", -level => 'VERBOSE') ;
    foreach my $branch (@localbranches) {
      $branch  =~  s/^\s+|\s+$//g;
      $remote  =~  s/^\s+|\s+$//g;
      if(grep m&remotes/$remote/$branch&, @remotebranches) {
        my $out = `(cd \"${path}\" && git branch --set-upstream-to $remote/$branch) 2>&1`;
        $? == 0 or report($out);
      } else {
        report("branch `$branch' has been created: when pushing upstream, use `git push -u $remote $branch' to configure future pull operations");
      }
    }
  } elsif ($status == -1) {
    error("could not execute command \"$fork_cmd\": $!\n$fork_output");
  } elsif ($status & 127) {
    error(sprintf("command \"$fork_cmd\" died with signal %d%s:\n$fork_output",
                  ($status & 128) ? ' (with coredump)' : q()));
  } else {
    error(sprintf("command \"$fork_cmd\" exited with status %d:\n$fork_output", $status >> 8));
  }
}


sub gh_fork {
  my ($path, $options) = @_;
  my $fork_cmd = "gh repo fork --remote=true";
  return ($fork_cmd, qx^( cd \"$path\" && $fork_cmd ) 2>&1^);
}


sub hub_fork {
  my ($path, $options) = @_;
  my $hubcred = File::Spec->catdir($ENV{HOME},'.config/hub');
  unless (-e $hubcred or defined $ENV{GITHUB_TOKEN} or (defined $ENV{GITHUB_USER} and defined $ENV{GITHUB_PASSWORD})) {
    my $err_msg = << 'EOM';
   Neither "gh" (GitHub CLI) nor "hub" commands are available and authorized to interact with this repository on GitHub.

   * For "gh", execute:

       gh auth login

     and follow the prompts. A personal access token can be obtained at
     https://github.com/settings/tokens.

   * For "hub":

       Hub will prompt for your GitHub username and password the first
       time it needs to access the API and exchange it for an OAuth
       token, which it saves in ~/.config/hub.

       To avoid being prompted, use GITHUB_USER and GITHUB_PASSWORD environment variables.

       Alternatively, you may provide the environment variable
       GITHUB_TOKEN (see https://github.com/settings/tokens), an access
       token with repo permissions. This will not be written to
       ~/.config/hub.

     To check and/or obtain credentials, execute:

       hub api -t

EOM
       error("$err_msg");
     }
  my $fork_cmd = "hub fork --remote-name=origin";
  return ($fork_cmd, qx^( cd \"$path\" && $fork_cmd ) 2>&1^);
}

####################################
# update_cmake - Add an entry for the specified product to
#                CMakeLists.txt.
#
# Usage: update_cmake($destination)
sub update_cmake {
  my $destination = shift;
  my $product_deps = File::Spec->join("$destination", "ups", "product_deps");
  if (-e $product_deps) {
    my $parent_line = `grep -e '^parent' "$product_deps"`;
    my ($parent) = ($parent_line =~ m&^parent\s+(\w+)&o);
    if ($parent ne $destination) {
      error("$product_deps specifies product name $parent but you have checked the repo out as $destination.",
            "\nPlease rectify either by renaming the top level directory or correcting the parent line in $product_deps.",
            "\nThen, add to CMakeLists.txt with add_to_cmake.sh \"$ENV{MRB_SOURCE}\" \"<product>\"");
    }
    my $cmakeliststxt = File::Spec->join($ENV{MRB_SOURCE}, "CMakeLists.txt");
    my $check_cmake_entry_cmd =
      sprintf("grep -q -e '(%s)' '$cmakeliststxt' >%s 2>&1",
              $destination,
              File::Spec->devnull());
    my @update_cmake_cmd = ("$libexec/add_to_cmake.sh", "$ENV{MRB_SOURCE}", "${destination}");
    (system($check_cmake_entry_cmd) == 0 and
     (report("CMakeLists.txt entry for product $destination already exists"), 1)) or
       (system(@update_cmake_cmd) == 0 and
        (report("Entry added to CMakeLists.txt for product $destination",
                -level => "VERBOSE"), 1)) or
                  error("unable to add product $destination to CMakeLists.txt");
  } else {
    report("product ${destination} does not appear to have a ${product_deps} file: not adding to CMakeLists.txt",
           "\nExecute add_to_cmake.sh \"$ENV{MRB_SOURCE}\" \"${destination}\" when you have created it.",
          -level => "WARNING");
  }
}

####################################
# get_repo - Execute all operations for the repo as specified by the
#            given prod_info hash.
#
# Usage: get_repo(%prod_info)
sub get_repo {
  my $prod_info = shift;
  if ($options->{"read-only"} and exists $prod_info->{user_url}) {
    report("read-only global specification ignored for repo $prod_info->{repo} with user-specified url $prod_info->{user_url}",
           -level => "INFO")
  }
  my $repo_type = $prod_info->{selected_type};
  error("repo type $repo_type not supported for checkout of $prod_info->{product}")
    unless exists $prod_info->{$repo_type};
  my $repo = $prod_info->{$repo_type}->{repo};
  my $repo_name = repo_name($prod_info->{$repo_type}->{repo});
  if ($repo_type eq "github" and $options->{"github-org"}) {
    # Update the github info hash with updated github org / user.
    $repo = sprintf('%s/%s',  $options->{"github-org"}, $repo_name);
  }

  my $destination = $options->{destination}
    || $prod_info->{product}
    || $repo_name;
  if (-e $destination) {
    report("$destination already exists", -level => "WARNING");
  } else {
    my $url = verified_url($repo_type, $prod_info->{$repo_type});
    my $want_shallow =
      (not ($repo_type eq "fnal" and $url =~ m&^https?://&)) ?
        $options->{shallow} || 0: 0;
    if ($options->{shallow} and not $want_shallow) {
      report("shallow clones not supported for $repo_type repositories via HTTP(S): executing full clone",
            -level=> "WARNING");
    }
    clone_repo($url, $destination,
               @{$prod_info->{$repo_type}->{git_args} || []},
               ($want_shallow) ? qw(--depth 1 --shallow-submodules) : ()
              );
  }

  # Post-processing for checked-out repository.
  if (exists $prod_info->{$repo_type}->{post}) {
    if ($options->{"dry-run"}) {
      report("would apply post-processing to checked-out repository $destination",
            -level => "INFO");
    } else {
      &{$prod_info->{$repo_type}->{post}}($destination, $options)
        if $prod_info->{$repo_type}->{post};
    }
  }

  # Fork checked-out repository if selected.
  if ($options->{"fork"} and exists $prod_info->{$repo_type}->{post}) {
    if ($options->{"dry-run"}) {
      report("would fork checked-out repository $destination",
            -level => "INFO");
    } else {
      &{$prod_info->{$repo_type}->{fork}}($destination, $options)
        if $prod_info->{$repo_type}->{fork};
    }
  }

  # Check out selected tree-ish.
  my $tree_ish = $prod_info->{"tree-ish"} || $global_tree_ish;
  if ($tree_ish) {
    if ($options->{"dry-run"}) {
      report("would check out $tree_ish for repository $destination",
             -level => "INFO");
    } else {
      checkout_tree_ish($destination, $tree_ish)
    }
  }

  # Update CMakeLists.txt.
  if ($options->{"dry-run"}) {
    report ("Would update CMakeLists.txt for checked-out repository $destination",
            -level => "INFO");
  } else {
    update_cmake($destination);
  }
}

####################################
# expand_and_process_repo_specs - Process all non-option arguments.
#
# Usage: expand_and_process_repo_specs(@repo_specs)
sub expand_and_process_repo_specs {
  my @repo_specs = @_;
  my @expanded_specs = ();
  while (my $repo_spec = shift @repo_specs) {
    my @suite_items = $options->{"no-expand"} ?
      () :
      expand_suite(${repo_spec});
    if (@suite_items) {
      report(sprintf("expanded $repo_spec to %s items: %s",
                     scalar @suite_items,
                    join(", ", @suite_items)),
             -level => "VERBOSE");
      unshift @repo_specs, @suite_items;
    } else {
      push @expanded_specs, $repo_spec;
    }
  }
  if (scalar @expanded_specs > 1) {
    if ($options->{destination}) {
      error("destination specification is meaningless if multiple repositories are specified");
    } elsif ($options->{commit}) {
      error("commit specification is meaningless if multiple repositories are specified");
    }
  }
  foreach my $repo_spec (@expanded_specs) {
    report("processing repo specification $repo_spec", -level => "VERBOSE");
    get_repo(process_repo_spec($repo_spec));
  }
}

####################################
# longest string - ascertain the longest argument.
#
# Usage: longest_string(@args)
#
# Returns the longest argument in the provided list.
sub longest_string {
  my $max = -1;
  my $max_ref;
  for (@_) {
    if (length > $max) {
      $max = length;
      $max_ref = \$_;
    }
  }
  return $$max_ref;
}

####################################
# print_version - Print the version of this program.
#
# Usage: print_version()
sub print_version() {
  print "${prog} ${version}\n";
}

####################################
# print_repo_types - Print the known repository types.
#
# Usage: print_repo_types()
sub print_repo_types {
  print "Known repository types: \n\n";
  my $unimplemented;
  foreach my $repo_type (sort keys %{$repo_handlers}) {
    my $handler = $repo_handlers->{$repo_type};
    $handler or $unimplemented = 1;
    printf "  %s%s\n", $repo_type, (defined $handler) ? "" : " (unimplemented)";
  }
  print "\nN.B. If a desired repository type is missing or currently unimplemented, ", repo_type_request("<type>"), "\n"
    if ($unimplemented);
}

####################################
# print_known_suites - Print the known suites and their pertinent
#                      information.
sub print_known_suites() {
  print "Known suites: \n\n";
  my $sl = length longest_string(map { "${_}_suite"; } keys %{$known_suites});
  printf "%-${sl}s    Repositories\n", "Suite";
  print map { sprintf("%-${sl}s    %s\n",
                      "${_}_suite",
                      join(" ", @{$known_suites->{$_}})); }
    sort keys %{$known_suites};
}

########################################################################
# Main code.
GetOptions($options,
           "help|h|?",
           "branch|b=s",
           "commit|c=s",
           "debug",
           "destination|directory|product|d=s",
           "dry-run|n",
           "fork|f",
           "github-org|ghorg|ghuser|g=s",
           "help-repos",
           "help-suites",
           "help-repo-types",
           "no-expand",
           "quiet|q",
           "read-only|r",
           "repo-type=s",
           "shallow",
           "tag|t=s",
           "verbose|v",
           "version|V",
          ) or pod2usage(-exitval => 2, -width => 132);

if ($options->{help}) {
  pod2usage(-exitval => 1, -verbose => 3);
} elsif ($options->{"help-repo-types"}) {
  print_repo_types();
  exit(1);
} elsif ($options->{"help-repos"}) {
  print Dumper $known_products;
  exit(1);
} elsif ($options->{"help-suites"}) {
  print_known_suites();
  exit(1);
} elsif ($options->{version}) {
  print_version();
  exit(1);
}

# Linked options.
$options->{verbose} = 1 if ($options->{debug});
delete $options->{quiet} if $options->{verbose};

my @tree_ish_args = grep m&(branch|commit|tree)&, sort keys %{$options};

if (scalar @tree_ish_args > 1) {
  error("mutually-exclusive tree-ish options specified: ",
        join(",", @tree_ish_args));
}

$global_tree_ish =
  $options->{branch} || $options->{commit} || $options->{tag} || undef;

my @REP = @ARGV;

scalar @REP or
  error("no products specified!", -exitval => 2, -usage => 1);

$ENV{MRB_SOURCE} or
error("MRB_SOURCE must be defined and non-empty: source the appropriate localProductsXXX/setup");

chdir($ENV{MRB_SOURCE}) or
error("unable to change directory to MRB_SOURCE ($ENV{MRB_SOURCE})");

if ($options->{destination} and
    scalar File::Spec->splitdir($options->{destination}) > 1) {
  error("destination specification must be a name, not a path");
}

expand_and_process_repo_specs(@REP);

1;

=pod

=head1 NAME

mrb gitCheckout - Clone one or more git repositories or suites to your development area.

=head1 SYNOPSIS

B<mrb gitCheckout|g> B<-h|--help|-?> | B<--help-repo-types> | B<--help-repos> | B<--help-suites>

B<mrb gitCheckout|g> B<-V>

B<mrb gitCheckout|g> [B<-b|--branch> I<branch> | B<-c|--commit> I<commit> | B<-t|--tag> I<tag>] [B<--debug>] [B<-d|--destination|--directory|--product> I<name>] [B<--fork|-f>] [B<--dry-run|-n>] [B<--github-org|--ghorg|-g> I<ghorg>] [B<--no-expand>] [B<-q|--quiet>] [B<-r|--read-only>] [B<--repo-type> I<type>] [B<-V|--version>] [B<-v|--verbose>] [--] I<spec>+

B<+> implies optional repeated arguments.

I<spec> may be a suite, product name, repository name or URL. For a full explanation of this flexibility, see section L</ARGUMENTS> with B<--help>.

=head1 DESCRIPTION

mrb gitCheckout facilitates the ordered checkout of one or more repositories or suites. It knows about many suites and common products. In addition to cloning the repository, mrb gitCheckout will initialize git flow and add an entry to the F<CMakeLists.txt> file if necessary.

=head2 OPTIONS

=over 2

=item B<--branch> I<branch>

=item B<-b> I<branch>

After cloning, check out the specified I<branch>. Mutually-exclusive with B<--commit> and B<--tag>. Overridden by per-repository I<tree-ish> specification (see L</ARGUMENTS>).

=item B<--commit> I<commit>

=item B<-c> I<commit>

After cloning, check out the specified I<commit>. Mutually-exclusive with B<--branch> and B<--tag>. Overridden by per-repository I<tree-ish> specification. It is an error to specify --commit with multiple repository specifications.

=item B<--debug>

Show messages to aid debugging (implies B<-v>)

=item B<--destination> I<name>

=item B<--directory> I<name>

=item B<-d> I<name>

=item B<--product> I<name>

Clone the repository into the specified I<name>. It is an error to specify B<--directory> with multiple repository specifications. It is an error to specify B<--directory> if it is inconsistent with a product's name as specified in F<ups/product_deps>. This option overrides the I<product> component of I<spec>, if given. The latter, however, is the recommended mechanism for specifying the product name as it is more flexible and specific.

=item B<--dry-run>

=item B<-n>

Don't actually check out any repositories.

=item B<--fork>

=item B<-f>

Run `hub fork` after cloning GitHub repo.

=item B<--github-org> I<ghorg>

=item B<--ghorg> I<ghorg>

=item B<-g> I<ghorg>

Use the provided ghorg for github checkouts. Overrides known repository information (see B<--help-repos>); is in turn overridden by specified URIs.

=item B<--help>

=item B<-h>

=item B<-?>

This help.

=item B<--help-repos>

Print the list of known repositories and their main attributes.

=item B<--help-suites>

Print the list of known suites and their repositories.

=item B<--help-repo-types>

Print the list of known repository types.

=item B<--no-expand>

Disable the expansion of known suites, repositories and products.

=item B<--quiet>

=item B<-q>

Print only warnings and errors (overridden by B<--verbose>).

=item B<--read-only>

=item B<-r>

Check out the repository in read-only mode.

=item B<--repo-type> I<repo-type>

Specify the repository type as I<repo-type>. Overridden by per-repository I<type> specification (see L</ARGUMENTS>).

=item B<--tag> I<tag>

=item B<-t> I<tag>

After cloning, check out the specified I<tag>. Mutually-exclusive with B<--branch> and B<--commit>. Overridden by per-repository I<tree-ish> specification (see L</ARGUMENTS>).

=item B<--verbose>

=item B<-v>

Increase verbosity (overrides B<--quiet>).

=item B<--version>

=item B<-V>

Print version.

=back

=head2 ARGUMENTS

A I<spec> may be:

=over 2

=item I<suite>[@I<branch|tag>]

If known, suite is expanded to its list of repositories, otherwise I<spec> is interpreted per below. See B<--help-suites> for a table of known suites. This form is not available if the B<--no-expand> option is used. While B<mrb gitCheckout> is not capable of detecting the specification of a commit rather than a branch or tag here, its use is contraindicated and will almost certainly not do what you want.

=item [I<product>%] I<URL> [@I<branch|commit|tag>] [[+]^I<git_arg>[^I<git_arg>]...]

If not specified, I<product> is inferred from the basename of the URL.

=item S<[I<product>%] [I<type>:]I<repo>[%I<user>] [@I<branch|commit|tag>]> [[+]^I<git_arg>[^I<git_arg>]...]

=item [I<type>:]I<product> [@I<branch|commit|tag>] [[+]^I<git_arg>[^I<git_arg>]...]

[Spaces in the above are for formating clarity only and should be omitted in actual usage.]

If not specified, I<type> defaults to C<fnal>, or as specified with B<--repo-type>. See B<--help-repo-types> for a full list of known types.

If not specified, I<product> defaults to I<repo> and vice-versa.

If a known product or repository is recognized, its information is merged with any user-provided information with the latter taking priority. Merging can be prevented with the B<--no-expand> option. Note that user-specified git arguments will B<replace> any known internally for that product unless the first I<^> is preceded by a I<+>, in which case the user specified ones are appended (and therefore override where appropriate) those from the internal product specification.


=back

=head2 EXAMPLES

=over 4

=item B<mrb g> larsoft_suite@v07_01_00

=item B<mrb g> -t v07_01_00 larsoft_suite

Check out all the constituent repositories of the larsoft suite at the specified suite version.

=item B<mrb g> -r art@art-v2-develop

Check out the (known) art repository on the specified branch in read-only mode.

=item S<B<mrb g> -v my_repo%fnal:my-prj_my-repo%my-prj@feature/cool-stuff+^-v>

=item S<B<mrb g> -v -b feature/cool-stuff my_repo%fnal:my-prj_my-repo%my-prj+^-v>

Check out the B<feature/cool-stuff> branch of the C<my-repository_my-repo> branch from FNAL Redmine as the product C<my_repo> with the URL as calculated to be C<ssh://p-my-prj@cdcvs.fnal.gov/cvs/projects/my-prj_my-repo>, per the rules for FNAL Redmine repositories. Provide verbose messages. The I<-v> (verbose) option will be appended to the S<B<git clone>> operation's arguments.

=back

=cut
