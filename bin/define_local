#!/usr/bin/env perl
#
# setup products for the build environment
# use product_deps and MRB_QUALS

use File::Basename;
use lib dirname($0);

use mrb_parse_deps;


if( $#ARGV < 1 ) {
    $errfl1 = "problem_report";
    open(ERR1, "> $errfl1") or die "Couldn't open $errfl1";
    print ERR1 "\n";
    print ERR1 "unsetenv_ CETPKG_NAME\n";
    print ERR1 "unsetenv_ CETPKG_VERSION\n";
    print ERR1 "unsetenv_ CETPKG_QUAL\n";
    print ERR1 "unsetenv_ CETPKG_TYPE\n";
    print ERR1 "unsetenv_ CETPKG_CC\n";
    print ERR1 "unsetenv_ CETPKG_CXX\n";
    print ERR1 "unsetenv_ CETPKG_FC\n";
    print ERR1 "echo \"ERROR: directory not specified\"\n";
    print ERR1 "echo \"USAGE: define_local <input-directory> <build-directory> [extra qualifiers]>\"\n";
    print ERR1 "return 1\n";
    close(ERR1);
    print "$errfl1\n";
    exit 0;
}

$sourcedir = $ARGV[0];
$builddir = $ARGV[1];
$simple = "";
for $i ( 2 .. $#ARGV ) {
    if( $ARGV[$i] eq "simple" ) {
      $simple = "true";
    } else {
      $extra_qual = $extra_qual.$ARGV[$i].":";
    }
}

# use this file for debugging
$diagfl = $builddir."/diag_report";
open(DIAG, ">> $diagfl") or die "Couldn't open $diagfl";

$inputdir = $sourcedir."/ups";

$mrb_project = $ENV{MRB_PROJECT};
$mrb_version = $ENV{MRB_PROJECT_VERSION};
$mrb_quals = $ENV{MRB_QUALS};
$tmpfl = $builddir."/".$mrb_project."-".$mrb_version."-defs";
##print DIAG "opening $tmpfl for $mrb_project $mrb_version\n";
open(TSET, "+> $tmpfl") or die "Couldn't open $tmpfl";

##print DIAG "setup_products debug info: cmakefile  is $cmakefile\n";

# parse a list of dependencies
$dfile = $sourcedir."/dependency_list";
%deplist = get_dependency_list( $dfile, DIAG );

# have to find the list of packages to traverse
$cmakefile=$sourcedir."/CMakeLists.txt";
@package_list = get_package_list( $cmakefile, DIAG );
##print DIAG "DIAGNOSTICS: packages to check: @package_list\n";
if ( $#package_list < 0 ) {
  print DIAG "DIAGNOSTICS: there are no packages in $sourcedir\n";
  print DIAG "DIAGNOSTICS: nothing to build\n";
  print "$tmpfl\n";
  exit 0;
}
for $i ( 0 .. $#package_list ) {
  $pkg=$package_list[$i];
  $pfile=$sourcedir."/".$pkg."/ups/product_deps";
  ##print DIAG "checking $pfile for $pkg \n";
  ($productnames[$i], $productversn[$i]) = get_product_name( $pfile, DIAG );
  $productdefaultquals[$i] = find_default_qual( $pfile );
  ##print DIAG "DIAGNOSTICS: $productdefaultquals[$i] for $productnames[$i]\n";
}

# unsetup if necessary
print TSET "# unsetup products we are building\n";
##print DIAG "DIAGNOSTICS: packages to check: @package_list\n";
for $i ( 0 .. $#package_list ) {
  # call unsetup if the $productnames[$i] has been setup
  $psetup = "SETUP_".uc($productnames[$i]);
  $is_setup=$ENV{$psetup};
  ##print DIAG "DIAGNOSTICS: $psetup for $productnames[$i] is $is_setup\n";
  if ( $is_setup ) {
    print TSET "unsetup -j $productnames[$i]\n";
  }
}

# loop again and define package variables
print TSET "# set package variables\n";
my $build_dir = $ENV{MRB_BUILDDIR};
for $i ( 0 .. $#package_list ) {
  $pkg=$package_list[$i];
  $pfile=$sourcedir."/".$pkg."/ups/product_deps";
  ##print DIAG "checking $pfile for $pkg \n";
  $product = $productnames[$i];
  $version = $productversn[$i];
  $qual    = $productdefaultquals[$i]; 

  $fcl_directory = get_fcl_directory( $pfile, $product );
  $gdml_directory = get_gdml_directory( $pfile, $product );
  $fw_directory = get_fw_directory( $pfile, $product );
  # pretend this is a product
  $product_uc = uc($product);
  print TSET "setenv  ${product_uc}_VERSION $version\n";
  # dropit -esf will remove any existing instances of the path and then prepend the path
  # unfortunately, tcsh complains if the variable is not already set, so we have to check
  if ( $ENV{PATH} ne '' ) {
    print TSET "setenv  PATH \`dropit -esf -p \${PATH} \'${build_dir}/${product}/bin\'\`\n";
  } else {
    print TSET "setenv  PATH \'${build_dir}/${product}/bin\'\n";
  }
  if ( $ENV{LD_LIBRARY_PATH} ne '' ) {
    print TSET "setenv  LD_LIBRARY_PATH \`dropit -esf -p \${LD_LIBRARY_PATH} \'${build_dir}/${product}/lib\'\`\n";
  } else {
    print TSET "setenv  LD_LIBRARY_PATH \'${build_dir}/${product}/lib\'\n";
  }
  if ( $ENV{DYLD_LIBRARY_PATH} ne '' ) {
    print TSET "setenv  DYLD_LIBRARY_PATH \`dropit -esf -p \${DYLD_LIBRARY_PATH} \'${build_dir}/${product}/lib\'\`\n";
  } else {
    print TSET "setenv  DYLD_LIBRARY_PATH \'${build_dir}/${product}/lib\'\n";
  }
  if ( "${fcl_directory}" ne "none" ) {
    ##print DIAG "$product: add ---${fcl_directory}---\n";
     # Note - this previously just set FHICL_FILE_PATH if it wasn't already set - the problem with that
     # was then the last product to get set up would be the only one
     print TSET "setenv  FHICL_FILE_PATH \`dropit -esf -p \${FHICL_FILE_PATH} \'${build_dir}/${fcl_directory}\'\`\n";
  }
  if ( "${gdml_directory}" ne "none" ) {
    if ( $ENV{FW_SEARCH_PATH} ne '' ) {
      print TSET "setenv  FW_SEARCH_PATH \`dropit -esf -p \${FW_SEARCH_PATH} \'${build_dir}/${gdml_directory}\'\`\n";
    } else {
      print TSET "setenv  FW_SEARCH_PATH \'${build_dir}/${gdml_directory}\'\n";
    }
  }
  if ( "${fw_directory}" ne "none" ) {
    if ( $ENV{FW_SEARCH_PATH} ne '' ) {
      print TSET "setenv  FW_SEARCH_PATH \`dropit -esf -p \${FW_SEARCH_PATH} \'${build_dir}/${fw_directory}\'\`\n";
    } else {
      print TSET "setenv  FW_SEARCH_PATH \'${build_dir}/${fw_directory}\'\n";
    }
  }

}
# make sure we still have the local directory (and ensure the dot only appears once)
print TSET "setenv  FHICL_FILE_PATH \`dropit -esf -p \${FHICL_FILE_PATH} \'.\'\`\n";
#print TSET "setenv  FHICL_FILE_PATH .:\${FHICL_FILE_PATH}\n";

# cleanup
close(TSET);
close(DIAG);
print "$tmpfl\n";


exit 0;
