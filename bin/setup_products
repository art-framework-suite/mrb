#!/usr/bin/env perl
#
# setup products for the build environment
# use product_deps and qualifier_deps

# we need to know the qualifiers
# -d, -o, or -p and 1-2 other qualifiers

use File::Basename;
use lib dirname($0);


if( $#ARGV < 2 ) {
    $errfl1 = "problem_report";
    open(ERR1, "> $errfl1") or die "Couldn't open $errfl1";
    print ERR1 "\n";
    print ERR1 "unsetenv_ CETPKG_NAME\n";
    print ERR1 "unsetenv_ CETPKG_VERSION\n";
    print ERR1 "unsetenv_ CETPKG_QUAL\n";
    print ERR1 "unsetenv_ CETPKG_TYPE\n";
    print ERR1 "echo \"ERROR: directory and qualifiers not specified\"\n";
    print ERR1 "echo \"USAGE: setup_products <input-directory> <-d|-o|-p> <qualifiers>\"\n";
    print ERR1 "return 1\n";
    close(ERR1);
    print "$errfl1\n";
    exit 0;
}

$sourcedir = $ARGV[0];
$builddir = $ARGV[1];
$simple = "";
for $i ( 2 .. $#ARGV ) {
    if( $ARGV[$i] eq "-d" ) {
      $dop = "debug";
      $type = "Debug";
    } elsif( $ARGV[$i] eq "-o" ) {
      $dop = "opt";
      $type = "Opt";
    } elsif( $ARGV[$i] eq "-p" ) {
      $dop = "prof";
      $type = "Prof";
    } elsif( $ARGV[$i] eq "simple" ) {
      $simple = "true";
    } else {
      $incoming_qual = $incoming_qual.$ARGV[$i].":";
      $qdir = $qdir.$ARGV[$i]."-";
    }
}

# use this file for debugging
$diagfl = $builddir."/diag_report";
open(DIAG, "+> $diagfl") or die "Couldn't open $diagfl";

$srcbase = basename($sourcedir);
if ( $srcbase eq "ups" ) {
    $inputdir = $sourcedir;
    ##print DIAG "setup_products debug info: have the old setup_for_development\n";
    $errfl2 = "problem_report";
    open(ERR2, "> $errfl2") or die "Couldn't open $errfl2";
    print ERR2 "\n";
    print ERR2 "unsetenv_ CETPKG_NAME\n";
    print ERR2 "unsetenv_ CETPKG_VERSION\n";
    print ERR2 "unsetenv_ CETPKG_QUAL\n";
    print ERR2 "unsetenv_ CETPKG_TYPE\n";
    print ERR2 "echo \"ERROR: \"\n";
    print ERR2 "echo \"ERROR: you have an old copy of setup_for_development\"\n";
    print ERR2 "echo \"ERROR: please issue the following command\"\n";
    print ERR2 "echo \"ERROR: cp \$CETBUILDTOOLS_DIR/templates/setup_for_development.template $inputdir/setup_for_development\"\n";
    print ERR2 "echo \"ERROR: \"\n";
    print ERR2 "return 1\n";
    close(ERR2);
    print "$errfl2\n";
    exit 0;
} else {
    $inputdir = $sourcedir."/ups";
}
##print DIAG "setup_products debug info: source dir is $sourcedir\n";
##print DIAG "setup_products: incoming qual is $incoming_qual\n";

require mrb_parse_deps;

$mrb_project = $ENV{MRB_PROJECT};
$mrb_version = $ENV{MRB_VERSION};
$mrb_quals = $ENV{MRB_QUALS};
$tmpfl = $builddir."/".$mrb_project."-".$mrb_version;
##print DIAG "opening $tmpfl for $mrb_project $mrb_version\n";
open(TSET, "+> $tmpfl") or die "Couldn't open $tmpfl";

##print DIAG "setup_products debug info: cmakefile  is $cmakefile\n";
print TSET "setenv UPS_OVERRIDE -B\n";
print TSET "setenv CETPKG_NAME $mrb_project\n";
print TSET "setenv CETPKG_VERSION $mrb_version\n";
if ( $simple ) {
  print TSET "unsetenv_ CETPKG_QUAL\n";
  print TSET "unsetenv_ CETPKG_TYPE\n";
} else {
  print TSET "setenv CETPKG_QUAL $mrb_quals\n";
  print TSET "setenv CETPKG_TYPE $type\n";
}

# parse a list of dependencies
$dfile = $sourcedir."/dependency_list";
%deplist = get_dependency_list( $dfile, DIAG );

# have to find the list of packages to traverse
$cmakefile=$sourcedir."/CMakeLists.txt";
@package_list = get_package_list( $cmakefile, DIAG );
##print DIAG "DIAGNOSTICS: packages to check: $#package_list @package_list\n";
for $i ( 0 .. $#package_list ) {
  $pkg=$package_list[$i];
  $pfile=$sourcedir."/".$pkg."/ups/product_deps";
  ##print DIAG "checking $pfile for $pkg \n";
  ($productnames[$i], $productversn[$i]) = get_product_name( $pfile, DIAG );
  # call unsetup if the $productnames[$i] has been setup
  $psetup = "SETUP_".uc($productnames[$i]);
  $is_setup=$ENV{$psetup};
  ##print DIAG "$psetup for $productnames[$i] is $is_setup\n";
  if ( $is_setup ) {
    print TSET "unsetup -j $productnames[$i]\n";
  }
  $cetbver[$i] = find_cetbuildtools( $pfile );
  ##print DIAG "DIAGNOSTICS: cetbuildtools $cetbver[$i]\n";
  print TSET "setup -B cetbuildtools $cetbver[$i]\n";
  print TSET "test \"\$?\" = 0 || set_ setup_fail=\"true\"\n"; 
}
print TSET "setup -B cetpkgsupport \n";
print TSET "test \"\$?\" = 0 || set_ setup_fail=\"true\"\n"; 
##print DIAG "DIAGNOSTICS: product name $#productnames @productnames\n";
##print DIAG "DIAGNOSTICS: product version $#productversn @productversn\n";
@setup_list=( cetbuildtools, cetpkgsupport );
for $i ( 0 .. $#package_list ) {
  $pkg=$package_list[$i];
  $pkgdir = $builddir."/".$pkg;
  unless ( -e $pkgdir or mkdir $pkgdir ) { die "Couldn't create $pkgdir"; }
  $pfile=$sourcedir."/".$pkg."/ups/product_deps";
  #print DIAG "checking $pfile for $pkg \n";
  ($product, $version, $default_ver, $default_qual, %phash) = parse_product_list( $pfile, DIAG );
  ##print DIAG "found $product $version $default_ver $default_qual\n";
  ##print DIAG "should match $productnames[$i] $productversn[$i]\n";
  if ( $product ne $productnames[$i] ) {
     print DIAG "ERROR: product names do not match: $product vs $productnames[$i]\n";
     exit 1;
  }
  if ( $version ne $productversn[$i] ) {
     print DIAG "ERROR: version names do not match: $version vs $productversn[$i]\n";
     exit 1;
  }
  # continue parsing for this package
  ($ndeps, @qlist) = parse_qualifier_list( $pfile, TSET );

  if ( $incoming_qual ) {
    $qual = $incoming_qual.$dop;
    $qdir = $incoming_qdir.$dop;
  } else {
    $dq = find_default_qual( $pfile );
    if ( $dq ) {
      $qual = $dq.":";
      $qdir = $dq."-";
      $qual = $qual.$dop;
      $qdir = $qdir.$dop;
    } elsif ( $simple ) {
      $qual = "-nq-";
    } else {
      $errfl2 = $builddir."/error-".$product."-".$version;
      open(ERR2, "> $errfl2") or die "Couldn't open $errfl2";
      print ERR2 "\n";
      print ERR2 "unsetenv_ CETPKG_NAME\n";
      print ERR2 "unsetenv_ CETPKG_VERSION\n";
      print ERR2 "unsetenv_ CETPKG_QUAL\n";
      print ERR2 "unsetenv_ CETPKG_TYPE\n";
      print ERR2 "echo \"ERROR: no qualifiers specified\"\n";
      print ERR2 "echo \"ERROR: add a defaultqual line to $pfile\"\n";
      print ERR2 "echo \"ERROR: or specify the qualifier(s) on the command line\"\n";
      print ERR2 "echo \"USAGE: setup_products <input-directory> <-d|-o|-p> <qualifiers>\"\n";
      print ERR2 "return 1\n";
      close(ERR2);
      print "$errfl2\n";
      exit 0;
    }
  }
  print DIAG "setup_products: using qualifier $qual for $product\n";

  (%ohash) = find_optional_products( $pfile );
  ($ecount, @ehash) = find_only_for_build_products( $pfile );

  foreach $i ( 1 .. $ecount ) {
    $print_setup=true;
    foreach $j ( 0 .. $#setup_list ) {
      if( $ehash[$i][0] eq $setup_list[$j] ) {
        $print_setup=false;
      }
    }
    if ( $print_setup eq "true" ) {
      print TSET "setup -B $ehash[$i][0] $ehash[$i][1]\n";
      print TSET "test \"\$?\" = 0 || set_ setup_fail=\"true\"\n"; 
    }
  }
  # are there products without listed qualifiers?
  @pkeys = keys %phash;
  foreach $i ( 1 .. $#pkeys ) {
    ##print DIAG "searching for $pkeys[$i] qualifiers in $product\n";
    $p_has_qual = 0;
    foreach $k ( 0 .. $#setup_list ) {
      if( $pkeys[$i] eq $setup_list[$k] ) {
	     $p_has_qual++;
      } else {
	foreach $j ( 1 .. $ndeps ) {
	  if ( $pkeys[$i] eq $qlist[0][$j] ) {
	     $p_has_qual++;
	  }
	}
      }
    }
    if ( $p_has_qual == 0 ) {
      print_setup_noqual( $pkeys[$i], $phash{$pkeys[$i]}, $ohash{$pkeys[$i]}, "", TSET );
    }
  }
  # now loop over the qualifier list
  $match = 0;
  foreach $i ( 1 .. $#qlist ) {
    if ( compare_qual( $qlist[$i][0], $qual ) ) {
      $match++;
      foreach $j ( 1 .. $ndeps ) {
	$print_setup=true;
	# are we building this product?
	for $k ( 0 .. $#productnames ) {
	  if ( $productnames[$k] eq $qlist[0][$j] ) {
	     $print_setup=false;
	  }
	}
	# is this product already in the setup list?
	foreach $k ( 0 .. $#setup_list ) {
	  if( $setup_list[$k] eq $qlist[0][$j] ) {
	    $print_setup=false;
	  }
	}
	##print DIAG "should I setup $qlist[0][$j]? ${print_setup}\n";
        if ( $print_setup eq "true" ) {
	  push( @setup_list, $qlist[0][$j] );
	  # is this part of my extended package list?
	  # if it is in the middle of the build list, use setup -j
	  # if we are not building anything it depends on, use regular setup
	  $usej = check_product_dependencies( $qlist[0][$j], \%deplist, \@package_list, DIAG );
	  ##print DIAG "check_product_dependencies returned $usej\n";
	  if ( $qlist[$i][$j] eq "-" ) {
	  } elsif ( $qlist[$i][$j] eq "-nq-" ) {
            print_setup_noqual( $qlist[0][$j], $phash{$qlist[0][$j]}, $ohash{$qlist[0][$j]}, $usej, TSET );
	  } elsif ( $qlist[$i][$j] eq "-b-" ) {
            print_setup_noqual( $qlist[0][$j], $phash{$qlist[0][$j]}, $ohash{$qlist[0][$j]}, $usej, TSET );
	  } else {
	    @qwords = split(/:/,$qlist[$i][$j]);
	    $ql="+".$qwords[0];
	    foreach $j ( 1 .. $#qwords ) {
	      $ql = $ql.":+".$qwords[$j];
	    }
            print_setup_qual( $qlist[0][$j], $phash{$qlist[0][$j]}, $ql, $ohash{$qlist[0][$j]}, $usej, TSET );
	  }
	}
      }
    }
  }
  # allow for the case where there are no dependencies
  if ( $match == 0 ) {
     if( $phash{none} eq "none" ) {
       #print "this package has no dependencies\n";
     } else {
       print TSET "\n";
       print TSET "echo \"ERROR: failed to find any dependent products for $product $version -q $qual\"\n";
       print TSET "echo \"       The following qualifier combinations are recognized:\"\n";
       foreach $i ( 1 .. $#qlist ) {
	   print TSET "echo \"         $qlist[$i][0] \"\n";
       }
       print TSET "return 1\n";
       print TSET "\n";
     }
  }
  $cetfl = cetpkg_info_file( $product, $version, $default_ver, $qual, $type, $sourcedir, $pkgdir );
  # pretend this is a product
  $product_uc = uc($product);
  print TSET "setenv  ${product_uc}_VERSION $version\n";

}
$cetfl = cetpkg_info_file( $mrb_project, $mrb_version, $mrb_version, $mrb_quals, $type, $sourcedir, $builddir );

# cleanup
close(TSET);
close(DIAG);
print "$tmpfl\n";


exit 0;
